let BigNumber,ethers,config,fetch,ABI,addresses;_38e‍.x([["TAssetArbitrageur",()=>TAssetArbitrageur]]);_38e‍.w("ethers",[["BigNumber",["BigNumber"],function(v){BigNumber=v}],["ethers",["ethers"],function(v){ethers=v}]]);_38e‍.w("dotenv",[["config",["config"],function(v){config=v}]]);_38e‍.w("node-fetch",[["fetch",["fetch"],function(v){fetch=v}]]);_38e‍.w("./abi.mjs",[["ABI",["ABI"],function(v){ABI=v}]]);_38e‍.w("./address.mjs",[["addresses",["addresses"],function(v){addresses=v}]]);






config()


       class TAssetArbitrageur {

    constructor(tasset) {
        this.rpcURL = "https://bsc-dataseed.binance.org/";
        this.provider = new ethers.providers.JsonRpcProvider(this.rpcURL);
        this.wallet = new ethers.Wallet.fromMnemonic(process.env.SEED)
        this.wallet = this.wallet.connect(this.provider)

        this.threshold = 0.005  // abt threshold default 1%
        this.positionSize = null
        this.deadline = 5 // in minutes
        this.slippage = 0.05  // max slippage 1%
        this.gasPrice = 5  // gwei
        
        this.twindexSwapFee = 0.003
        this.twindexMintFee = 0.003
        this.twindexRedeemFee = 0.007
        this.tasset = tasset

        this.contract = this.initContract()
    }

    initContract() {
        return {
            token: { kusd: new ethers.Contract(addresses.stablecoin.kusd, ABI.token.kusd, this.provider) },
            twindex: { swap: new ethers.Contract(addresses.twindex.swap, ABI.twindex.swap, this.wallet) },
            quickMint: new ethers.Contract(addresses.twindex.quickMint, ABI.twindex.quickMint,this.wallet),
            syntheticController: new ethers.Contract(addresses.twindex.synthController, ABI.tasset.controller, this.wallet),
            twindexRouter: new ethers.Contract(addresses.twindex.router, ABI.twindex.router, this.wallet),
            tasset: {
                token: new ethers.Contract(addresses.tassets[this.tasset].token, ABI.tasset.token, this.provider),
                swap: new ethers.Contract(addresses.tassets[this.tasset].lp, ABI.tasset.lp, this.wallet),
                synthPool: new ethers.Contract(addresses.tassets[this.tasset].synthPool, ABI.tasset.synthPool, this.wallet),
                linkOracle: new ethers.Contract(addresses.tassets[this.tasset].oracle, ABI.tasset.oracle, this.provider)
            }
        }
    }

    async getPancakePrice(address) {
        const response = await fetch(
            `https://api.pancakeswap.info/api/v2/tokens/${address}`,
            { "method": "GET" }
        )
        return response.json();
    }

    async getTAssetSwapPrice() {
        const contracts = this.contract.tasset.swap
        const token0 = await contracts.token0()
        const [token0Reserve, token1Reserve] = await contracts.getReserves()

        if (token0 === addresses.stablecoin.kusd) {
            // token0 = kusd, token1 = tasset
            return token0Reserve / token1Reserve
        } else {
            // token1 = kusd, token0 = tasset
            return token1Reserve / token0Reserve
        }
    }

    async getReserves() {
        const contracts = this.contract.tasset.swap
        const token0 = await contracts.token0()
        const [token0Reserve, token1Reserve] = await contracts.getReserves()

        if (token0 === addresses.stablecoin.kusd) {
            // token0 = kusd, token1 = tasset
            return {
                kusd: token0Reserve,
                tasset: token1Reserve
            }
        } else {
            // token1 = kusd, token0 = tasset
            return {
                tasset: token0Reserve,
                kusd: token1Reserve
            }
        }
    }

    async getOraclePrice() {
        return await this.contract.tasset.token.getSynthPrice() / 1e18
    }

    async swapTAsset(positionSize, reserve) {
        // define deadline
        const deadline = + new Date() + this.deadline * 60
        // get amountIn from positionSize, and path
        let amountIn = ethers.utils.parseEther(positionSize.toString())  // in wei
        // calculate amountOutMin
        const amountInWithFee = positionSize * (1. - this.twindexSwapFee) * 1e18  // defuct twindex fee 0.3%
        const numerator = amountInWithFee * reserve.tasset
        const denominator = + reserve.kusd + amountInWithFee
        const amountOut = numerator / denominator
        const amountOutMin = BigNumber.from((amountOut * (1. - this.slippage)).toString()) // in wei
        // routing path and wallet address
        const path = [this.contract.token.kusd.address, this.contract.tasset.token.address]
        const to = this.wallet.address
        const gasLimit = await this.contract.twindexRouter.estimateGas.swapExactTokensForTokens(
            amountIn,
            amountOutMin,
            path,
            to,
            deadline
        )
        const gasFee = ((this.gasPrice * 1e9) * gasLimit) / 1e18  // canvert gasPrice to wei, and gasFee to Ether (BNB)
        const bnbPrice = (await this.getPancakePrice(addresses.wbnb)).price;

        _38e‍.g.console.log(`Swapping ${positionSize.toFixed(4)} KUSD. ` +
            `Minimum Receive ${parseFloat(amountOutMin.toString()).toFixed(4)}. ` +
            `\nGas Fee: ${gasFee.toFixed(6)} BNB ($({)gasFee * bnbPrice).toFixed(2)} USD)`)

        const option = {
            gasPrice: ethers.utils.parseUnits(this.gasPrice.toString(), "gwei"),
            gasLimit: gasLimit.toString(),
        }
        // return await this.contract.twindexRouter.swapExactTokensForTokens(
        //     amountIn,
        //     amountOutMin,
        //     path,
        //     to,
        //     deadline,
        //     option
        // )
    }

    async mintTAsset(amountIn) {
        const quickMinter = this.contract.quickMint;
        const oraclePrice = await this.getOraclePrice();
        const amountInWithFee = amountIn * (1. - this.twindexMintFee)
        const collateralRatio = this.contract.syntheticController.globalCollateralRatio() / 1e18
        

        const collateralAmount = ethers.utils.parseEther(amountIn.toString());  // * 1e18
        // const swapShareOutMin;
        // const offset;
        // const synthOutMin;

        // const gasLimit = quickMinter.estimateGas.quickMint(
        //     this.contract.tasset.synthPool,
        //     collateralAmount,
        //     swapShareOutMin,
        //     offset,
        //     synthOutMin
        // )
        // const gasFee = ((this.gasPrice * 1e9) * gasLimit) / 1e18  // canvert gasPrice to wei, and gasFee to Ether (BNB)
    }

    async redeemTAsset(amountIn) {
        const tassetSynthPool = this.contract.tasset.synthPool;
        tassetSynthPool.estimateGas.redeemFractionalSynth()
    }

    async computePremium() {

    }

    async computeDiscount() {
        
        
    }

    async computePositionSize(desiredPrice, assetIn, reserve) {
        // assetIn \in {kusd, tasset}
        // = kusd => buy tasset, else sell tasset
        const assetOut = assetIn == 'kusd' ? 'tasset' : 'kusd'
        const reserveIn = +reserve[assetIn] / 1e18
        const reserveOut = +reserve[assetOut] / 1e18

        const sqrt_term = (reserveOut * (desiredPrice + 2)) ** 2 + 4 * (desiredPrice * reserveIn * reserveOut - reserveIn ** 2)
        const solution = [
            ((-reserveOut * (desiredPrice + 2)) + sqrt_term ** 0.5) / 2, 
            ((-reserveOut * (desiredPrice + 2)) - sqrt_term ** 0.5) / 2, 
        ]
        return solution[0] > 0 ? solution[0] : solution[1];
    }

    async executeArbitrage() {
        
        // get tasset oracle price
        const oraclePrice = await this.getOraclePrice()
        // get tasset swap price
        const swapPrice = await this.getTAssetSwapPrice(this.tasset)
        // get pct diff
        const pctDiff = (swapPrice - oraclePrice) / oraclePrice
        // calculate position size
        const reserve = await this.getReserves()
        
        console.log(`Oracle Price: ${oraclePrice}; Swap Price: ${swapPrice} (${(pctDiff*100).toFixed(2)}%)`)
        // console.log(`Position sizing with ${positionSize.toFixed(4)} KUSD`)
        // if pct idff > threshold
        if (Math.abs(pctDiff) >= this.threshold) {
            if (oraclePrice > swapPrice) {
                // if oracle > swap (discount) -> buy tasset and redeem twx+kusd -> sell twx -> get kusd
                // swap KUSD
                console.log(`tAsset ${this.tasset} is currently discount!`)
                const positionSize = await this.computePositionSize(oraclePrice, 'kusd', reserve)
                const tx = await this.swapTAsset(positionSize, reserve)
                
            } else {
                // else oracle < swap (premium) -> buy twx for collateral -> mint and sell -> get kusd
                console.log(`tAsset ${this.tasset} is currently premium!`)
                // const positionSize = await this.calculatePositionSize()
                // const calculatedOutcomes = await this.computePreimum();

                // const mintTx = await this.mintTAsset(tasset, positionSize);
                // const tassetBalance = await this.getTassetBalance(tasset);
                // const swapTx = await this.swapTAsset(tasset, tassetBalance);
                
            }
        }
    }

    async runTAssetArbitrage() {
        // listen on block
        console.log("Initializing oracle price adjust listener...")

        this.executeArbitrage()
        // const oracleFilter = {
        //     address: this.contract.tasset[tasset].linkOracle.address,
        //     topics: [
        //         '0xf6a97944f31ea060dfde0566e4167c1a1082551e64b60ecb14d599a9d023d451'
        //     ]
        // }
        // this.provider.on(oracleFilter, async (log, event) => {
        //     const txnHash = log.transactionHash
        //     console.log(`Oracle price ${tasset} updated!`)
        //     console.log(`Transaction hash: ${txnHash}`)
        //     this.executeArbitrage(tasset)
        // })
        
        // const swapFilter = {
        //     address: this.contract.tasset[tasset].swap.address,
        //     topics: [
        //         '0xd78ad95fa46c994b6551d0da85fc275fe613ce37657fb8d5e3d130840159d822',
        //     ]
        // }
        // console.log(`Initializing KUSD-${tasset} swap listener...`)
        // this.provider.on(swapFilter, async(log, event) => {
        //     const txnHash = log.transactionHash
        //     console.log("Someone swapped on Twindex!")
        //     console.log(`Transaction hash: ${txnHash}`)
        //     this.executeArbitrage(tasset)
        // })
    }

}